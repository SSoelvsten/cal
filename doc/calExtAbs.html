<html>
<head><title>cal package abstract</title></head>
<body>


<!-- Function Abstracts -->

<dl>
<dt> <a href="calAllDet.html#Cal_AssociationInit" TARGET="MAIN"><code>Cal_AssociationInit()</code></a>
<dd> Creates or finds a variable association.

<dt> <a href="calAllDet.html#Cal_AssociationQuit" TARGET="MAIN"><code>Cal_AssociationQuit()</code></a>
<dd> Deletes the variable association given by id

<dt> <a href="calAllDet.html#Cal_AssociationSetCurrent" TARGET="MAIN"><code>Cal_AssociationSetCurrent()</code></a>
<dd> Sets the current variable association to the one given by id and
  returns the ID of the old association.

<dt> <a href="calAllDet.html#Cal_BddAnd" TARGET="MAIN"><code>Cal_BddAnd()</code></a>
<dd> Returns the BDD for logical AND of argument BDDs

<dt> <a href="calAllDet.html#Cal_BddBetween" TARGET="MAIN"><code>Cal_BddBetween()</code></a>
<dd> Returns a minimal BDD whose function contains fMin and is
  contained in fMax.

<dt> <a href="calAllDet.html#Cal_BddCofactor" TARGET="MAIN"><code>Cal_BddCofactor()</code></a>
<dd> Returns the generalized cofactor of BDD f with respect
  to BDD c.

<dt> <a href="calAllDet.html#Cal_BddCompose" TARGET="MAIN"><code>Cal_BddCompose()</code></a>
<dd> composition - substitute a BDD variable by a function

<dt> <a href="calAllDet.html#Cal_BddDependsOn" TARGET="MAIN"><code>Cal_BddDependsOn()</code></a>
<dd> Returns 1 if f depends on var and returns 0 otherwise.

<dt> <a href="calAllDet.html#Cal_BddDumpBdd" TARGET="MAIN"><code>Cal_BddDumpBdd()</code></a>
<dd> Write a BDD to a file

<dt> <a href="calAllDet.html#Cal_BddDynamicReordering" TARGET="MAIN"><code>Cal_BddDynamicReordering()</code></a>
<dd> Specify dynamic reordering technique.

<dt> <a href="calAllDet.html#Cal_BddElse" TARGET="MAIN"><code>Cal_BddElse()</code></a>
<dd> Returns the negative cofactor of the argument BDD with
  respect to the top variable of the BDD.

<dt> <a href="calAllDet.html#Cal_BddExists" TARGET="MAIN"><code>Cal_BddExists()</code></a>
<dd> Returns the result of existentially quantifying some
  variables from the given BDD.

<dt> <a href="calAllDet.html#Cal_BddForAll" TARGET="MAIN"><code>Cal_BddForAll()</code></a>
<dd> Returns the result of universally quantifying some
  variables from the given BDD.

<dt> <a href="calAllDet.html#Cal_BddFree" TARGET="MAIN"><code>Cal_BddFree()</code></a>
<dd> Frees the argument BDD.

<dt> <a href="calAllDet.html#Cal_BddFunctionPrint" TARGET="MAIN"><code>Cal_BddFunctionPrint()</code></a>
<dd> Prints the function implemented by the argument BDD

<dt> <a href="calAllDet.html#Cal_BddFunctionProfileMultiple" TARGET="MAIN"><code>Cal_BddFunctionProfileMultiple()</code></a>
<dd> Returns a "function profile" for fArray.

<dt> <a href="calAllDet.html#Cal_BddFunctionProfile" TARGET="MAIN"><code>Cal_BddFunctionProfile()</code></a>
<dd> Returns a "function profile" for f.

<dt> <a href="calAllDet.html#Cal_BddGetIfId" TARGET="MAIN"><code>Cal_BddGetIfId()</code></a>
<dd> Returns the id of the top variable of the argument BDD.

<dt> <a href="calAllDet.html#Cal_BddGetIfIndex" TARGET="MAIN"><code>Cal_BddGetIfIndex()</code></a>
<dd> Returns the index of the top variable of the argument BDD.

<dt> <a href="calAllDet.html#Cal_BddGetRegular" TARGET="MAIN"><code>Cal_BddGetRegular()</code></a>
<dd> Returns a BDD with positive from a given BDD with arbitrary phase

<dt> <a href="calAllDet.html#Cal_BddITE" TARGET="MAIN"><code>Cal_BddITE()</code></a>
<dd> Returns the BDD for logical If-Then-Else

  Description [Returns the BDD for the logical operation IF f THEN g ELSE h
  - f g + f' h

<dt> <a href="calAllDet.html#Cal_BddIdentity" TARGET="MAIN"><code>Cal_BddIdentity()</code></a>
<dd> Returns the duplicate BDD of the argument BDD.

<dt> <a href="calAllDet.html#Cal_BddIf" TARGET="MAIN"><code>Cal_BddIf()</code></a>
<dd> Returns the BDD corresponding to the top variable of
  the argument BDD.

<dt> <a href="calAllDet.html#Cal_BddImplies" TARGET="MAIN"><code>Cal_BddImplies()</code></a>
<dd> Computes a BDD that implies conjunction of f and Cal_BddNot(g)

<dt> <a href="calAllDet.html#Cal_BddIntersects" TARGET="MAIN"><code>Cal_BddIntersects()</code></a>
<dd> Computes a BDD that implies conjunction of f and g.

<dt> <a href="calAllDet.html#Cal_BddIsBddConst" TARGET="MAIN"><code>Cal_BddIsBddConst()</code></a>
<dd> Returns 1 if the argument BDD is a constant, 0 otherwise.

<dt> <a href="calAllDet.html#Cal_BddIsBddNull" TARGET="MAIN"><code>Cal_BddIsBddNull()</code></a>
<dd> Returns 1 if the argument BDD is NULL, 0 otherwise.

<dt> <a href="calAllDet.html#Cal_BddIsBddOne" TARGET="MAIN"><code>Cal_BddIsBddOne()</code></a>
<dd> Returns 1 if the argument BDD is constant one, 0 otherwise.

<dt> <a href="calAllDet.html#Cal_BddIsBddZero" TARGET="MAIN"><code>Cal_BddIsBddZero()</code></a>
<dd> Returns 1 if the argument BDD is constant zero, 0 otherwise.

<dt> <a href="calAllDet.html#Cal_BddIsCube" TARGET="MAIN"><code>Cal_BddIsCube()</code></a>
<dd> Returns 1 if the argument BDD is a cube, 0 otherwise

<dt> <a href="calAllDet.html#Cal_BddIsEqual" TARGET="MAIN"><code>Cal_BddIsEqual()</code></a>
<dd> Returns 1 if argument BDDs are equal, 0 otherwise.

<dt> <a href="calAllDet.html#Cal_BddIsProvisional" TARGET="MAIN"><code>Cal_BddIsProvisional()</code></a>
<dd> Returns 1, if the given user BDD contains
  provisional BDD node.

<dt> <a href="calAllDet.html#Cal_BddManagerCreateNewVarAfter" TARGET="MAIN"><code>Cal_BddManagerCreateNewVarAfter()</code></a>
<dd> Creates and returns a new variable after the specified one in
  the variable  order.

<dt> <a href="calAllDet.html#Cal_BddManagerCreateNewVarBefore" TARGET="MAIN"><code>Cal_BddManagerCreateNewVarBefore()</code></a>
<dd> Creates and returns a new variable before the specified one in
  the variable order.

<dt> <a href="calAllDet.html#Cal_BddManagerCreateNewVarFirst" TARGET="MAIN"><code>Cal_BddManagerCreateNewVarFirst()</code></a>
<dd> Creates and returns a new variable at the start of the variable
  order.

<dt> <a href="calAllDet.html#Cal_BddManagerCreateNewVarLast" TARGET="MAIN"><code>Cal_BddManagerCreateNewVarLast()</code></a>
<dd> Creates and returns a new variable at the end of the variable
  order.

<dt> <a href="calAllDet.html#Cal_BddManagerGC" TARGET="MAIN"><code>Cal_BddManagerGC()</code></a>
<dd> Invokes the garbage collection at the manager level.

<dt> <a href="calAllDet.html#Cal_BddManagerGetHooks" TARGET="MAIN"><code>Cal_BddManagerGetHooks()</code></a>
<dd> Returns the hooks field of the manager.

<dt> <a href="calAllDet.html#Cal_BddManagerGetNumNodes" TARGET="MAIN"><code>Cal_BddManagerGetNumNodes()</code></a>
<dd> Returns the number of BDD nodes

<dt> <a href="calAllDet.html#Cal_BddManagerGetVarWithId" TARGET="MAIN"><code>Cal_BddManagerGetVarWithId()</code></a>
<dd> Returns the variable with the specified id, null if no
  such variable exists

<dt> <a href="calAllDet.html#Cal_BddManagerGetVarWithIndex" TARGET="MAIN"><code>Cal_BddManagerGetVarWithIndex()</code></a>
<dd> Returns the variable with the specified index, null if no
  such variable exists

<dt> <a href="calAllDet.html#Cal_BddManagerInit" TARGET="MAIN"><code>Cal_BddManagerInit()</code></a>
<dd> Creates and initializes a new BDD manager.

<dt> <a href="calAllDet.html#Cal_BddManagerQuit" TARGET="MAIN"><code>Cal_BddManagerQuit()</code></a>
<dd> Frees the BDD manager and all the associated allocations

<dt> <a href="calAllDet.html#Cal_BddManagerSetGCLimit" TARGET="MAIN"><code>Cal_BddManagerSetGCLimit()</code></a>
<dd> Sets the limit of the garbage collection.

<dt> <a href="calAllDet.html#Cal_BddManagerSetHooks" TARGET="MAIN"><code>Cal_BddManagerSetHooks()</code></a>
<dd> Sets the hooks field of the manager.

<dt> <a href="calAllDet.html#Cal_BddManagerSetParameters" TARGET="MAIN"><code>Cal_BddManagerSetParameters()</code></a>
<dd> Sets appropriate fields of BDD Manager.

<dt> <a href="calAllDet.html#Cal_BddMultiwayAnd" TARGET="MAIN"><code>Cal_BddMultiwayAnd()</code></a>
<dd> Returns the BDD for logical AND of argument BDDs

<dt> <a href="calAllDet.html#Cal_BddMultiwayOr" TARGET="MAIN"><code>Cal_BddMultiwayOr()</code></a>
<dd> Returns the BDD for logical OR of argument BDDs

<dt> <a href="calAllDet.html#Cal_BddMultiwayXor" TARGET="MAIN"><code>Cal_BddMultiwayXor()</code></a>
<dd> Returns the BDD for logical XOR of argument BDDs

<dt> <a href="calAllDet.html#Cal_BddNand" TARGET="MAIN"><code>Cal_BddNand()</code></a>
<dd> Returns the BDD for logical NAND of argument BDDs

<dt> <a href="calAllDet.html#Cal_BddNewVarBlock" TARGET="MAIN"><code>Cal_BddNewVarBlock()</code></a>
<dd> Creates and returns a variable block used for
  controlling dynamic reordering.

<dt> <a href="calAllDet.html#Cal_BddNodeLimit" TARGET="MAIN"><code>Cal_BddNodeLimit()</code></a>
<dd> Sets the node limit to new_limit and returns the old limit.

<dt> <a href="calAllDet.html#Cal_BddNor" TARGET="MAIN"><code>Cal_BddNor()</code></a>
<dd> Returns the BDD for logical NOR of argument BDDs

<dt> <a href="calAllDet.html#Cal_BddNot" TARGET="MAIN"><code>Cal_BddNot()</code></a>
<dd> Returns the complement of the argument BDD.

<dt> <a href="calAllDet.html#Cal_BddOne" TARGET="MAIN"><code>Cal_BddOne()</code></a>
<dd> Returns the BDD for the constant one

<dt> <a href="calAllDet.html#Cal_BddOr" TARGET="MAIN"><code>Cal_BddOr()</code></a>
<dd> Returns the BDD for logical OR of argument BDDs

<dt> <a href="calAllDet.html#Cal_BddOverflow" TARGET="MAIN"><code>Cal_BddOverflow()</code></a>
<dd> Returns 1 if the node limit has been exceeded, 0 otherwise. The
  overflow flag is cleared.

<dt> <a href="calAllDet.html#Cal_BddPairwiseAnd" TARGET="MAIN"><code>Cal_BddPairwiseAnd()</code></a>
<dd> Returns an array of BDDs obtained by logical AND of BDD pairs
  specified by an BDD array in which a BDD at an even location is paired with
  a BDD at an odd location of the array

<dt> <a href="calAllDet.html#Cal_BddPairwiseOr" TARGET="MAIN"><code>Cal_BddPairwiseOr()</code></a>
<dd> Returns an array of BDDs obtained by logical OR of BDD pairs
  specified by an BDD array in which a BDD at an even location is paired with
  a BDD at an odd location of the array

<dt> <a href="calAllDet.html#Cal_BddPairwiseXor" TARGET="MAIN"><code>Cal_BddPairwiseXor()</code></a>
<dd> Returns an array of BDDs obtained by logical XOR of BDD pairs
  specified by an BDD array in which a BDD at an even location is paired with
  a BDD at an odd location of the array

<dt> <a href="calAllDet.html#Cal_BddPrintBdd" TARGET="MAIN"><code>Cal_BddPrintBdd()</code></a>
<dd> Prints a BDD in the human readable form.

<dt> <a href="calAllDet.html#Cal_BddPrintFunctionProfileMultiple" TARGET="MAIN"><code>Cal_BddPrintFunctionProfileMultiple()</code></a>
<dd> Cal_BddPrintFunctionProfileMultiple is like
               Cal_BddPrintFunctionProfile except for multiple BDDs

<dt> <a href="calAllDet.html#Cal_BddPrintFunctionProfile" TARGET="MAIN"><code>Cal_BddPrintFunctionProfile()</code></a>
<dd> Cal_BddPrintFunctionProfile is like Cal_BddPrintProfile except
               it displays a function profile for f

<dt> <a href="calAllDet.html#Cal_BddPrintProfileMultiple" TARGET="MAIN"><code>Cal_BddPrintProfileMultiple()</code></a>
<dd> Cal_BddPrintProfileMultiple is like Cal_BddPrintProfile except
               it displays the profile for a set of BDDs

<dt> <a href="calAllDet.html#Cal_BddPrintProfile" TARGET="MAIN"><code>Cal_BddPrintProfile()</code></a>
<dd> Displays the node profile for f on fp. lineLength specifies 
               the maximum line length.  varNamingFn is as in
               Cal_BddPrintBdd.

<dt> <a href="calAllDet.html#Cal_BddProfileMultiple" TARGET="MAIN"><code>Cal_BddProfileMultiple()</code></a>
<dd> 

<dt> <a href="calAllDet.html#Cal_BddProfile" TARGET="MAIN"><code>Cal_BddProfile()</code></a>
<dd> Returns a "node profile" of f, i.e., the number of nodes at each
  level in f.

<dt> <a href="calAllDet.html#Cal_BddReduce" TARGET="MAIN"><code>Cal_BddReduce()</code></a>
<dd> Returns a BDD which agrees with f for all valuations
  which satisfy c.

<dt> <a href="calAllDet.html#Cal_BddRelProd" TARGET="MAIN"><code>Cal_BddRelProd()</code></a>
<dd> Returns the result of taking the logical AND of the
  argument BDDs and existentially quantifying some variables from the
  product.

<dt> <a href="calAllDet.html#Cal_BddReorder" TARGET="MAIN"><code>Cal_BddReorder()</code></a>
<dd> Invoke the current dynamic reodering method.

<dt> <a href="calAllDet.html#Cal_BddSatisfySupport" TARGET="MAIN"><code>Cal_BddSatisfySupport()</code></a>
<dd> Returns a special cube contained in f.

<dt> <a href="calAllDet.html#Cal_BddSatisfyingFraction" TARGET="MAIN"><code>Cal_BddSatisfyingFraction()</code></a>
<dd> Returns the fraction of valuations which make f true. (Note that
  this fraction is independent of whatever set of variables f is supposed to be
  a function of)

<dt> <a href="calAllDet.html#Cal_BddSatisfy" TARGET="MAIN"><code>Cal_BddSatisfy()</code></a>
<dd> Returns a BDD which implies f, true for
               some valuation on which f is true, and which has at most
               one node at each level

<dt> <a href="calAllDet.html#Cal_BddSetGCMode" TARGET="MAIN"><code>Cal_BddSetGCMode()</code></a>
<dd> Sets the garbage collection mode, 0 means the garbage
  collection should be turned off, 1 means garbage collection should
  be on.

<dt> <a href="calAllDet.html#Cal_BddSizeMultiple" TARGET="MAIN"><code>Cal_BddSizeMultiple()</code></a>
<dd> The routine is like Cal_BddSize, but takes a null-terminated
               array of BDDs and accounts for sharing of nodes.

<dt> <a href="calAllDet.html#Cal_BddSize" TARGET="MAIN"><code>Cal_BddSize()</code></a>
<dd> Returns the number of nodes in f when negout is nonzero. If
  negout is zero, we pretend that the BDDs don't have negative-output pointers.

<dt> <a href="calAllDet.html#Cal_BddStats" TARGET="MAIN"><code>Cal_BddStats()</code></a>
<dd> Prints miscellaneous BDD statistics

<dt> <a href="calAllDet.html#Cal_BddSubstitute" TARGET="MAIN"><code>Cal_BddSubstitute()</code></a>
<dd> Substitute a set of variables by functions

<dt> <a href="calAllDet.html#Cal_BddSupport" TARGET="MAIN"><code>Cal_BddSupport()</code></a>
<dd> returns the support of f as a null-terminated array of variables

<dt> <a href="calAllDet.html#Cal_BddSwapVars" TARGET="MAIN"><code>Cal_BddSwapVars()</code></a>
<dd> Return a function obtained by swapping two variables

<dt> <a href="calAllDet.html#Cal_BddThen" TARGET="MAIN"><code>Cal_BddThen()</code></a>
<dd> Returns the positive cofactor of the argument BDD with
  respect to the top variable of the BDD.

<dt> <a href="calAllDet.html#Cal_BddTotalSize" TARGET="MAIN"><code>Cal_BddTotalSize()</code></a>
<dd> Returns the number of nodes in the Unique table

<dt> <a href="calAllDet.html#Cal_BddType" TARGET="MAIN"><code>Cal_BddType()</code></a>
<dd> Returns type of a BDD ( 0, 1, +var, -var, ovrflow, nonterminal)

<dt> <a href="calAllDet.html#Cal_BddUnFree" TARGET="MAIN"><code>Cal_BddUnFree()</code></a>
<dd> Unfrees the argument BDD.

<dt> <a href="calAllDet.html#Cal_BddUndumpBdd" TARGET="MAIN"><code>Cal_BddUndumpBdd()</code></a>
<dd> Reads a BDD from a file

<dt> <a href="calAllDet.html#Cal_BddVarBlockReorderable" TARGET="MAIN"><code>Cal_BddVarBlockReorderable()</code></a>
<dd> Sets the reoderability of a particular block.

<dt> <a href="calAllDet.html#Cal_BddVarSubstitute" TARGET="MAIN"><code>Cal_BddVarSubstitute()</code></a>
<dd> Substitute a set of variables by set of another variables.

<dt> <a href="calAllDet.html#Cal_BddVars" TARGET="MAIN"><code>Cal_BddVars()</code></a>
<dd> Returns the number of BDD variables

<dt> <a href="calAllDet.html#Cal_BddXnor" TARGET="MAIN"><code>Cal_BddXnor()</code></a>
<dd> Returns the BDD for logical exclusive NOR of argument BDDs

<dt> <a href="calAllDet.html#Cal_BddXor" TARGET="MAIN"><code>Cal_BddXor()</code></a>
<dd> Returns the BDD for logical exclusive OR of argument BDDs

<dt> <a href="calAllDet.html#Cal_BddZero" TARGET="MAIN"><code>Cal_BddZero()</code></a>
<dd> Returns the BDD for the constant zero

<dt> <a href="calAllDet.html#Cal_MemAllocation" TARGET="MAIN"><code>Cal_MemAllocation()</code></a>
<dd> Returns the memory allocated.

<dt> <a href="calAllDet.html#Cal_MemFatal" TARGET="MAIN"><code>Cal_MemFatal()</code></a>
<dd> Prints an error message and exits.

<dt> <a href="calAllDet.html#Cal_MemFreeBlock" TARGET="MAIN"><code>Cal_MemFreeBlock()</code></a>
<dd> Frees the block.

<dt> <a href="calAllDet.html#Cal_MemFreeRecMgr" TARGET="MAIN"><code>Cal_MemFreeRecMgr()</code></a>
<dd> Frees all the storage associated with the specified record manager.

<dt> <a href="calAllDet.html#Cal_MemFreeRec" TARGET="MAIN"><code>Cal_MemFreeRec()</code></a>
<dd> Frees a record managed by the indicated record manager.

<dt> <a href="calAllDet.html#Cal_MemGetBlock" TARGET="MAIN"><code>Cal_MemGetBlock()</code></a>
<dd> Allocates a new block of the specified size.

<dt> <a href="calAllDet.html#Cal_MemNewRecMgr" TARGET="MAIN"><code>Cal_MemNewRecMgr()</code></a>
<dd> Creates a new record manager with the given  record size.

<dt> <a href="calAllDet.html#Cal_MemNewRec" TARGET="MAIN"><code>Cal_MemNewRec()</code></a>
<dd> Allocates a record from the specified record manager.

<dt> <a href="calAllDet.html#Cal_MemResizeBlock" TARGET="MAIN"><code>Cal_MemResizeBlock()</code></a>
<dd> Expands or contracts the block to a new size.
  We try to avoid moving the block if possible.

<dt> <a href="calAllDet.html#Cal_PerformanceTest" TARGET="MAIN"><code>Cal_PerformanceTest()</code></a>
<dd> Main routine for testing performances of various routines.

<dt> <a href="calAllDet.html#Cal_PipelineCreateProvisionalBdd" TARGET="MAIN"><code>Cal_PipelineCreateProvisionalBdd()</code></a>
<dd> Create a provisional BDD in the pipeline.

<dt> <a href="calAllDet.html#Cal_PipelineExecute" TARGET="MAIN"><code>Cal_PipelineExecute()</code></a>
<dd> Executes a pipeline.

<dt> <a href="calAllDet.html#Cal_PipelineInit" TARGET="MAIN"><code>Cal_PipelineInit()</code></a>
<dd> Initialize a BDD pipeline.

<dt> <a href="calAllDet.html#Cal_PipelineQuit" TARGET="MAIN"><code>Cal_PipelineQuit()</code></a>
<dd> Resets the pipeline freeing all resources.

<dt> <a href="calAllDet.html#Cal_PipelineSetDepth" TARGET="MAIN"><code>Cal_PipelineSetDepth()</code></a>
<dd> Set depth of a BDD pipeline.

<dt> <a href="calAllDet.html#Cal_PipelineUpdateProvisionalBdd" TARGET="MAIN"><code>Cal_PipelineUpdateProvisionalBdd()</code></a>
<dd> Update a provisional Bdd obtained during pipelining.

<dt> <a href="calAllDet.html#Cal_TempAssociationAugment" TARGET="MAIN"><code>Cal_TempAssociationAugment()</code></a>
<dd> Adds to the temporary variable association.

<dt> <a href="calAllDet.html#Cal_TempAssociationInit" TARGET="MAIN"><code>Cal_TempAssociationInit()</code></a>
<dd> Sets the temporary variable association.

<dt> <a href="calAllDet.html#Cal_TempAssociationQuit" TARGET="MAIN"><code>Cal_TempAssociationQuit()</code></a>
<dd> Cleans up temporary association

</dl>

<hr>

Last updated on 970711 20h11
</body></html>
