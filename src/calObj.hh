/**CPPHeaderFile***************************************************************

  FileName    [calObj.hh]

  PackageName [cal]

  Synopsis    [C++ Header CAL file for exported data structures and functions.]

  Description []

  SeeAlso     []

  Author      [Steffan SÃ¸lvsten (soelvsten@cs.au.dk)]

  Copyright   [Copyright (c) 2023, Aarhus University]

  All rights reserved.

  Permission is hereby granted, without written agreement and without license
  or royalty fees, to use, copy, modify, and distribute this software and its
  documentation for any purpose, provided that the above copyright notice and
  the following two paragraphs appear in all copies of this software.

  IN NO EVENT SHALL AARHUS UNIVERSITY OR THE UNIVERSITY OF CALIFORNIA BE LIABLE
  TO ANY PARTY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
  DAMAGES ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
  EITHER UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  BOTH UNIVERSITIES SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
  PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS,
  AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE,
  SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.]

  Revision    [$Id: calObj.h,v 3.0 2023/08/19 17:48:05 soelvsten Exp $]

******************************************************************************/

#ifndef _CALOBJ
#define _CALOBJ

extern "C" {
#include <cal.h>
#include <calInt.h>
}

#include <vector>
#include <sstream>
#include <string>

class BDD;
class Cal;

////////////////////////////////////////////////////////////////////////////////
/// \defgroup module__cpp C++ API
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
/// \addtogroup module__cpp
///
/// \{

////////////////////////////////////////////////////////////////////////////////
/// \brief C++ wrapper for `Cal_Bdd`, managing reference count with *RAII*.
///
/// \details These BDDs are created from a `Cal` object which owns the unique
/// node table. Hence, the life-time of any `BDD` object should not outlast its
/// parent `Cal` object. Doing so leads to *undefined behaviour*.
///
/// \see Cal
////////////////////////////////////////////////////////////////////////////////
class BDD
{
  friend Cal;

  //////////////////////////////////////////////////////////////////////////////
  // Types
public:
  //////////////////////////////////////////////////////////////////////////////
  /// \brief Type of BDD identifiers, i.e. the variable name independent of the
  ///        current variable ordering.
  //////////////////////////////////////////////////////////////////////////////
  using Id_t = Cal_BddId_t;

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Type of BDD indices, i.e. their placement in the current variable
  ///        ordering.
  //////////////////////////////////////////////////////////////////////////////
  using Index_t = Cal_BddIndex_t;

  //////////////////////////////////////////////////////////////////////////////
  // Members
private:
  /// \brief C API reference to BDD Manager (needed to call the C API).
  Cal_BddManager _bddManager;

  /// \brief C API reference to BDD node to be managed.
  Cal_Bdd _bdd;

  //////////////////////////////////////////////////////////////////////////////
  // Constructors
protected:

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Wrap C API `Cal_Bdd` to be managed by this new `BDD` object.
  ///
  /// \details This function does not increment the reference count of the given
  /// `Cal_Bdd`, assuming the C API operation already has done so.
  //////////////////////////////////////////////////////////////////////////////
  BDD(Cal_BddManager bddManager, Cal_Bdd bdd)
    : _bddManager(bddManager), _bdd(bdd)
  { }

public:
  //////////////////////////////////////////////////////////////////////////////
  /// \brief The `NULL` BDD.
  //////////////////////////////////////////////////////////////////////////////
  BDD()
    : _bddManager(NULL), _bdd(Cal_BddNull(NULL))
  { }

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Copies ownership of another BDD.
  //////////////////////////////////////////////////////////////////////////////
  BDD(const BDD &other)
    : _bddManager(other._bddManager), _bdd(other._bdd)
  {
    this->UnFree();
  }

  //////////////////////////////////////////////////////////////////////////////
  BDD& operator= (const BDD &other)
  {
    this->Free();

    this->_bdd = other._bdd;
    this->_bddManager = other._bddManager;

    this->UnFree();

    return *this;
  }

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Move ownership of another BDD.
  //////////////////////////////////////////////////////////////////////////////
  BDD(BDD &&other)
    : _bddManager(other._bddManager), _bdd(other._bdd)
  {
    other._bdd = Cal_BddNull(other._bddManager);
  }

  //////////////////////////////////////////////////////////////////////////////
  BDD& operator= (BDD &&other)
  {
    this->Free();

    this->_bdd = other._bdd;
    this->_bddManager = other._bddManager;

    other._bdd = Cal_BddNull(other._bddManager);

    return *this;
  }

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Decrement reference count upon leaving scope.
  //////////////////////////////////////////////////////////////////////////////
  ~BDD()
  {
    this->Free();
  }

  //////////////////////////////////////////////////////////////////////////////
  // Predicates
public:

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddIsBddOne
  //////////////////////////////////////////////////////////////////////////////
  bool IsOne() const
  { return Cal_BddIsBddOne(this->_bddManager, this->_bdd); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddIsBddZero
  //////////////////////////////////////////////////////////////////////////////
  bool IsZero() const
  { return Cal_BddIsBddZero(this->_bddManager, this->_bdd); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddIsBddNull
  //////////////////////////////////////////////////////////////////////////////
  bool IsNull() const
  { return BDD::IsNull(this->_bddManager, this->_bdd); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddIsBddConst
  //////////////////////////////////////////////////////////////////////////////
  bool IsConst() const
  { return Cal_BddIsBddConst(this->_bddManager, this->_bdd); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddIsCube
  //////////////////////////////////////////////////////////////////////////////
  bool IsCube() const
  { return Cal_BddIsCube(this->_bddManager, this->_bdd); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddIsEqual
  //////////////////////////////////////////////////////////////////////////////
  bool IsEqualTo(const BDD &other) const
  { return Cal_BddIsEqual(this->_bddManager, this->_bdd, other._bdd); }

  //////////////////////////////////////////////////////////////////////////////
  /// \see BDD::IsEqualTo
  //////////////////////////////////////////////////////////////////////////////
  bool operator== (const BDD &other) const
  { return this->IsEqualTo(other); }

  //////////////////////////////////////////////////////////////////////////////
  /// \see BDD::IsEqualTo
  //////////////////////////////////////////////////////////////////////////////
  bool  operator!= (const BDD &other) const
  { return !(*this == other); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddDependsOn
  //////////////////////////////////////////////////////////////////////////////
  bool DependsOn(const BDD &var) const
  { return Cal_BddDependsOn(this->_bddManager, this->_bdd, var._bdd); }

  //////////////////////////////////////////////////////////////////////////////
  // Node traversal and Information
public:

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddIf
  //////////////////////////////////////////////////////////////////////////////
  BDD If() const
  { return BDD(this->_bddManager, Cal_BddIf(this->_bddManager, this->_bdd)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddGetIfId
  //////////////////////////////////////////////////////////////////////////////
  Id_t Id() const
  { return Cal_BddGetIfId(this->_bddManager, this->_bdd); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddGetIfIndex
  //////////////////////////////////////////////////////////////////////////////
  Index_t Index() const
  { return Cal_BddGetIfIndex(this->_bddManager, this->_bdd); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddThen
  //////////////////////////////////////////////////////////////////////////////
  BDD Then() const
  { return BDD(this->_bddManager, Cal_BddThen(this->_bddManager, this->_bdd)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddElse
  //////////////////////////////////////////////////////////////////////////////
  BDD Else() const
  { return BDD(this->_bddManager, Cal_BddElse(this->_bddManager, this->_bdd)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Possible types a BDD can be.
  ///
  /// \see BDD::Type()
  //////////////////////////////////////////////////////////////////////////////
  enum Type_t
  {
    NONTERMINAL = CAL_BDD_TYPE_NONTERMINAL,
    ZERO        = CAL_BDD_TYPE_ZERO,
    ONE         = CAL_BDD_TYPE_ONE,
    POSVAR      = CAL_BDD_TYPE_POSVAR,
    NEGVAR      = CAL_BDD_TYPE_NEGVAR,
    OVERFLOW    = CAL_BDD_TYPE_OVERFLOW,
    CONSTANT    = CAL_BDD_TYPE_CONSTANT
  };

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddType
  //////////////////////////////////////////////////////////////////////////////
  Type_t Type() const
  { return static_cast<Type_t>(Cal_BddType(this->_bddManager, this->_bdd)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddSize
  ///
  /// \param negout If `false` then counting pretends the BDD does not have
  ///               negative-output pointers (complement edges).
  //////////////////////////////////////////////////////////////////////////////
  unsigned long Size(bool negout = true) const
  { return Cal_BddSize(this->_bddManager, this->_bdd, 0); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddSatisfyingFraction
  //////////////////////////////////////////////////////////////////////////////
  double SatisfyingFraction() const
  { return Cal_BddSatisfyingFraction(this->_bddManager, this->_bdd); }

  //////////////////////////////////////////////////////////////////////////////
  // Operations
public:

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddIdentity
  //////////////////////////////////////////////////////////////////////////////
  BDD Identity() const
  { return BDD(this->_bddManager, Cal_BddIdentity(this->_bddManager, this->_bdd)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddGetRegular
  //////////////////////////////////////////////////////////////////////////////
  BDD Regular() const
  {
    // Unlike other BDD operations of CAL, `Cal_BddGetRegular` does not
    // increment the reference count of its output. Hence, we have to do so here
    // to compensate for the `Free(...)` in `~BDD()`.
    BDD res(this->_bddManager, Cal_BddGetRegular(this->_bddManager, this->_bdd));
    BDD::UnFree(res._bddManager, res._bdd);
    return res;
  }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddNot
  //////////////////////////////////////////////////////////////////////////////
  BDD Not() const
  { return BDD(this->_bddManager, Cal_BddNot(this->_bddManager, this->_bdd)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \see BDD::Not
  //////////////////////////////////////////////////////////////////////////////
  BDD  operator~ () const
  { return this->Not(); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddCompose
  //////////////////////////////////////////////////////////////////////////////
  BDD Compose(const BDD &g, const BDD &h) const
  { return BDD(this->_bddManager, Cal_BddCompose(this->_bddManager, this->_bdd, g._bdd, h._bdd)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddIntersects
  //////////////////////////////////////////////////////////////////////////////
  BDD Intersects(const BDD &g) const
  { return BDD(this->_bddManager, Cal_BddIntersects(this->_bddManager, this->_bdd, g._bdd)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddImplies
  //////////////////////////////////////////////////////////////////////////////
  BDD Implies(const BDD &g) const
  { return BDD(this->_bddManager, Cal_BddImplies(this->_bddManager, this->_bdd, g._bdd)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddITE
  //////////////////////////////////////////////////////////////////////////////
  BDD ITE(const BDD &g, const BDD &h) const
  { return BDD(this->_bddManager, Cal_BddITE(this->_bddManager, this->_bdd, g._bdd, h._bdd)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddAnd
  //////////////////////////////////////////////////////////////////////////////
  BDD And(const BDD &g) const
  { return BDD(this->_bddManager, Cal_BddAnd(this->_bddManager, this->_bdd, g._bdd)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \see BDD::And
  //////////////////////////////////////////////////////////////////////////////
  BDD  operator& (const BDD &other) const
  { return this->And(other); }

  //////////////////////////////////////////////////////////////////////////////
  /// \see BDD::And
  //////////////////////////////////////////////////////////////////////////////
  BDD& operator&= (const BDD &other)
  { return (*this = (*this) & other); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddNand
  //////////////////////////////////////////////////////////////////////////////
  BDD Nand(const BDD &g) const
  { return BDD(this->_bddManager, Cal_BddNand(this->_bddManager, this->_bdd, g._bdd)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddOr
  //////////////////////////////////////////////////////////////////////////////
  BDD Or(const BDD &g) const
  { return BDD(this->_bddManager, Cal_BddOr(this->_bddManager, this->_bdd, g._bdd)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \see BDD::Or
  //////////////////////////////////////////////////////////////////////////////
  BDD  operator| (const BDD &other) const
  { return this->Or(other); }

  //////////////////////////////////////////////////////////////////////////////
  /// \see BDD::Or
  //////////////////////////////////////////////////////////////////////////////
  BDD& operator|= (const BDD &other)
  { return (*this = (*this) | other); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddNor
  //////////////////////////////////////////////////////////////////////////////
  BDD Nor(const BDD &g) const
  { return BDD(this->_bddManager, Cal_BddNor(this->_bddManager, this->_bdd, g._bdd)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddXor
  //////////////////////////////////////////////////////////////////////////////
  BDD Xor(const BDD &g) const
  { return BDD(this->_bddManager, Cal_BddXor(this->_bddManager, this->_bdd, g._bdd)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \see BDD::Xor
  //////////////////////////////////////////////////////////////////////////////
  BDD  operator^ (const BDD &other) const
  { return this->Xor(other); }

  //////////////////////////////////////////////////////////////////////////////
  /// \see BDD::Xor
  //////////////////////////////////////////////////////////////////////////////
  BDD& operator^= (const BDD &other)
  { return (*this = (*this) ^ other); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddXnor
  //////////////////////////////////////////////////////////////////////////////
  BDD Xnor(const BDD &g) const
  { return BDD(this->_bddManager, Cal_BddXnor(this->_bddManager, this->_bdd, g._bdd)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddSatisfy
  //////////////////////////////////////////////////////////////////////////////
  BDD Satisfy() const
  { return BDD(this->_bddManager, Cal_BddSatisfy(this->_bddManager, this->_bdd)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddSatisfySupport
  //////////////////////////////////////////////////////////////////////////////
  BDD SatisfySupport() const
  { return BDD(this->_bddManager, Cal_BddSatisfySupport(this->_bddManager, this->_bdd)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddSwapVars
  //////////////////////////////////////////////////////////////////////////////
  BDD SwapVars(const BDD &g, const BDD &h) const
  { return BDD(this->_bddManager, Cal_BddSwapVars(this->_bddManager, this->_bdd, g._bdd, h._bdd)); }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////
  // BDD RelProd(const BDD &g) const

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddCofactor
  //////////////////////////////////////////////////////////////////////////////
  BDD Cofactor(const BDD &c) const
  { return BDD(this->_bddManager, Cal_BddCofactor(this->_bddManager, this->_bdd, c._bdd)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddReduce
  //////////////////////////////////////////////////////////////////////////////
  BDD Reduce(const BDD &c) const
  { return BDD(this->_bddManager, Cal_BddReduce(this->_bddManager, this->_bdd, c._bdd)); }

  //////////////////////////////////////////////////////////////////////////////
  // Debugging
public:

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddPrintBdd
  //////////////////////////////////////////////////////////////////////////////
  void Print(FILE *fp = stdout) const
  {
    // TODO: Extend to use your own NamingFn and TerminalIdFn
    //       (and their environment).
    Cal_BddPrintBdd(this->_bddManager, this->_bdd,
                    Cal_BddNamingFnNone, Cal_BddTerminalIdFnNone, NULL,
                    fp);
  }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddFunctionPrint
  //////////////////////////////////////////////////////////////////////////////
  void FunctionPrint(std::string &name) const
  { Cal_BddFunctionPrint(this->_bddManager, this->_bdd, name.data()); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddProfile
  //////////////////////////////////////////////////////////////////////////////
  std::vector<long> Profile(bool negout = true) const
  {
    std::vector<long> results;
    results.reserve(Cal_BddVars(this->_bddManager)+1);
    Cal_BddProfile(this->_bddManager, this->_bdd, results.data(), negout);
    return results;
  }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddPrintProfile
  //////////////////////////////////////////////////////////////////////////////
  void PrintProfile(int lineLength = 79, FILE *fp = stdout) const
  {
    // TODO: Extend to use your own NamingFn (and its environment).
    Cal_BddPrintProfile(this->_bddManager, this->_bdd,
                        Cal_BddNamingFnNone, NULL,
                        lineLength, fp);
  }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddFunctionProfile
  //////////////////////////////////////////////////////////////////////////////
  std::vector<long> FunctionProfile() const
  {
    std::vector<long> results;
    results.reserve(Cal_BddVars(this->_bddManager)+1);
    Cal_BddFunctionProfile(this->_bddManager, this->_bdd, results.data());
    return results;
  }


  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddPrintFunctionProfile
  //////////////////////////////////////////////////////////////////////////////
  void PrintFunctionProfile(int lineLength = 79, FILE *fp = stdout) const
  {
    // TODO: Extend to use your own NamingFn (and its environment).
    Cal_BddPrintFunctionProfile(this->_bddManager, this->_bdd,
                                Cal_BddNamingFnNone, NULL,
                                lineLength, fp);
  }

  //////////////////////////////////////////////////////////////////////////////
  /// \brief The reference count of this BDD
  ///
  /// \details The reference count is a value between 0 and 255. If a reference
  /// count is 255 then incrementing or decrementing it has no effect. This is
  /// safe-guard constants and variables from being garbage collectd.
  //////////////////////////////////////////////////////////////////////////////
  int RefCount() const
  {
    if (this->IsNull()) {
      return 255; // <-- Simulate NULL has fixed MAX reference count.
    }

    CalBddNode_t *internal_node = CAL_BDD_POINTER(this->_bdd);

    int res;
    CalBddNodeGetRefCount(internal_node, res);

    return res;
  }

  //////////////////////////////////////////////////////////////////////////////
  /// \brief String representation of this BDD node.
  //////////////////////////////////////////////////////////////////////////////
  std::string ToString() const
  {
    if (this->IsNull()) { return "NULL"; }
    if (this->IsZero()) { return "(0)"; }
    if (this->IsOne())  { return "(1)"; }

    std::stringstream ss;
    ss << "("
       << this->Id() << ", "
       << this->Then()._bdd << ", "
       << this->Else()._bdd
       << ")";

    return ss.str();
  }

  //////////////////////////////////////////////////////////////////////////////
  // Conversion back and from C null-terminated arrays.
protected:

  /// \cond internal

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Convert an iterator of `BDD`s (or `int`s) into a `std::vector` of
  ///        `Cal_Bdd`.
  ///
  /// \detail By calling `.data()` on the result one exactly gets a list usable
  ///         in the C API.
  //////////////////////////////////////////////////////////////////////////////
  template<typename IT>
  static std::vector<Cal_Bdd>
  C_Bdd_vector(Cal_BddManager bddManager, IT begin, IT end)
  {
    // TODO: tidy up with template overloading

    std::vector<Cal_Bdd> out;
    out.reserve(std::distance(begin, end));

    while (begin != end) {
      const typename IT::value_type &x = *(begin++);

      if constexpr (std::is_same_v<typename IT::value_type, BDD>) {
        // TODO: assert same 'bddManager'...

        BDD::UnFree(x._bddManager, x._bdd);
        out.push_back(x._bdd);
      } else if constexpr (std::is_same_v<typename IT::value_type, int>) {
        out.push_back(Cal_BddManagerGetVarWithId(bddManager, x));
      }
    }

    out.push_back(Cal_BddNull(bddManager));

    return std::move(out);
  }

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Convert a null-terminated list of `Cal_Bdd`s from the C API to a
  ///        C++ vector of `BDD` classes.
  //////////////////////////////////////////////////////////////////////////////
  static std::vector<BDD>
  From_C_Array(Cal_BddManager bddManager, Cal_Bdd * bddArray)
  {
    std::vector<BDD> res;

    for (int i = 0; Cal_BddIsBddNull(bddManager, bddArray[i]) == 0; i++){
      if (CalBddPreProcessing(bddManager, 1, bddArray[i]) == 0){
        return std::vector<BDD>();
      }
      res.push_back(BDD(bddManager, bddArray[i]));
    }

    return std::move(res);
  }

  /// \endcond

  //////////////////////////////////////////////////////////////////////////////
  // Memory Management
private:

  /// \cond internal

  // TODO: move further down

  //////////////////////////////////////////////////////////////////////////////
  static inline bool
  IsNull(Cal_BddManager bddManager, Cal_Bdd f)
  { return Cal_BddIsBddNull(bddManager, f); }

  //////////////////////////////////////////////////////////////////////////////
  static inline void
  Free(Cal_BddManager bddManager, Cal_Bdd f)
  { if (!BDD::IsNull(bddManager, f)) Cal_BddFree(bddManager, f); }

  //////////////////////////////////////////////////////////////////////////////
  inline void
  Free()
  { BDD::Free(this->_bddManager, this->_bdd); }

  //////////////////////////////////////////////////////////////////////////////
  template<typename IT>
  static inline void
  Free(IT begin, IT end)
  {
    static_assert(std::is_same_v<typename IT::value_type, BDD>,
                  "Must be called with iterator for BDD");

    while (begin != end) (begin++)->Free();
  }

  //////////////////////////////////////////////////////////////////////////////
  template<typename IT>
  static inline void
  Free(Cal_BddManager bddManager, IT begin, IT end)
  {
    static_assert(std::is_same_v<typename IT::value_type, Cal_Bdd>,
                  "Must be called with iterator for Cal_Bdd");

    while (begin != end) BDD::Free(bddManager, *(begin++));
  }

  //////////////////////////////////////////////////////////////////////////////
  static inline void
  UnFree(Cal_BddManager bddManager, Cal_Bdd f)
  { if (!BDD::IsNull(bddManager, f)) Cal_BddUnFree(bddManager, f); }

  //////////////////////////////////////////////////////////////////////////////
  inline void
  UnFree()
  { BDD::UnFree(this->_bddManager, this->_bdd); }

  /// \endcond
};

////////////////////////////////////////////////////////////////////////////////
/// \brief Core Manager of everything BDDs, variables, and more.
///
/// \remark The `Cal` class is designed based on *non-sharing ownership*. You
/// can move the ownership to someone else, but you cannot create a copy of this
/// class to have multiple owners of the same BDD Manager. Please use C++
/// references instead.
////////////////////////////////////////////////////////////////////////////////
class Cal
{
  friend BDD;

  //////////////////////////////////////////////////////////////////////////////
  // Types

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Type of Cal's C++ BDD wrapping class.
  //////////////////////////////////////////////////////////////////////////////
  using Bdd_t = BDD;

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::Id_t
  //////////////////////////////////////////////////////////////////////////////
  using Id_t = BDD::Id_t;

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::Index_t
  //////////////////////////////////////////////////////////////////////////////
  using Index_t = BDD::Index_t;

  // ---------------------------------------------------------------------------
  // Fields
  //           TODO -----------------------------------------------
  //              Multiple Cal objects for the same Cal_BddManager
  //             ----------------------------------------------- TODO
  //
  //   Use a 'std::shared_ptr' for reference counting this 'Cal_BddManager'
  //   pointer. The 'Cal_BddManagerQuit' function is then the managed pointer's
  //   deleter.
  //
  //           NOTE -------------------------------------------- NOTE
  //
  //   If so, should all BDD objects also be part of this reference counting?
  //   Otherwise, if a BDD object survives for longer than the BDD manager, then
  //   it will result in Segmentation Faults. Arguably this is already an
  //   issue...
  Cal_BddManager _bddManager;

  //////////////////////////////////////////////////////////////////////////////
  // Constructors
public:

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Initialize a new BDD Manager.
  //////////////////////////////////////////////////////////////////////////////
  Cal()
    : _bddManager(Cal_BddManagerInit())
  { }

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Initialize a new BDD Manager with variables `[1, numVars]`.
  //////////////////////////////////////////////////////////////////////////////
  Cal(unsigned int numVars)
    : Cal()
  {
    // Create variables
    for (Id_t i = 0; i < numVars; ++i) {
      this->CreateNewVarLast();
    }
  }

  //////////////////////////////////////////////////////////////////////////////
  // TODO: Copy constructor (requires reference counting)
  Cal(const Cal &o) = delete;

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Move ownership of C object.
  //////////////////////////////////////////////////////////////////////////////
  Cal(Cal &&o)
    : _bddManager(o._bddManager)
  {
    o._bddManager = nullptr;
  }

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Clear memory of BDD Manager.
  ///
  /// \details If this object owns a `Cal_BddManager` from the C API, then that
  /// one is properly reset and freed.
  //////////////////////////////////////////////////////////////////////////////
  ~Cal()
  {
    if (this->_bddManager)
      Cal_BddManagerQuit(this->_bddManager);
  }

  //////////////////////////////////////////////////////////////////////////////
  // Settings + Statistics

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddManagerSetParameters
  //////////////////////////////////////////////////////////////////////////////
  void SetParameters(long reorderingThreshold,
                     long maxForwardedNodes,
                     double repackAfterGCThreshold,
                     double tableRepackThreshold)
  {
    return Cal_BddManagerSetParameters(this->_bddManager,
                                       reorderingThreshold,
                                       maxForwardedNodes,
                                       repackAfterGCThreshold,
                                       tableRepackThreshold);
  }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddManagerGetNumNodes
  //////////////////////////////////////////////////////////////////////////////
  unsigned long Nodes() const
  { return Cal_BddManagerGetNumNodes(this->_bddManager); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddVars
  //////////////////////////////////////////////////////////////////////////////
  long Vars() const
  { return Cal_BddVars(this->_bddManager); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddOverflow
  //////////////////////////////////////////////////////////////////////////////
  bool Overflow() const
  { return Cal_BddOverflow(this->_bddManager); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddTotalSize
  //////////////////////////////////////////////////////////////////////////////
  unsigned long TotalSize() const
  { return Cal_BddTotalSize(this->_bddManager); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddStats
  //////////////////////////////////////////////////////////////////////////////
  void Stats(FILE* fp = stdout) const
  { Cal_BddStats(this->_bddManager, fp); }

  // TODO: obtain error

  //////////////////////////////////////////////////////////////////////////////
  // Memory and Garbage Collection

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddNodeLimit
  //////////////////////////////////////////////////////////////////////////////
  long NodeLimit(long newLimit)
  { return Cal_BddNodeLimit(this->_bddManager, newLimit); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddSetGCMode
  //////////////////////////////////////////////////////////////////////////////
  void SetGCMode(bool enableGC)
  { Cal_BddSetGCMode(this->_bddManager, enableGC); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddManagerSetGCLimit
  //////////////////////////////////////////////////////////////////////////////
  void SetGCLimit()
  { Cal_BddManagerSetGCLimit(this->_bddManager); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddManagerGC
  //////////////////////////////////////////////////////////////////////////////
  void GC()
  { Cal_BddManagerGC(this->_bddManager); }

  //////////////////////////////////////////////////////////////////////////////
  // Reordering

  //////////////////////////////////////////////////////////////////////////////
  /// \brief The possible methods (algorithms) for variable reordering.
  ///
  /// \see Cal::DynamicReordering, Cal::ReorderMethod
  //////////////////////////////////////////////////////////////////////////////
  enum ReorderTechnique {
    NONE = CAL_REORDER_NONE,
    SIFT = CAL_REORDER_SIFT,
    WINDOW = CAL_REORDER_WINDOW
  };

  //////////////////////////////////////////////////////////////////////////////
  /// \brief The possible technique to be used to execute each method (c.f.
  /// `Cal::ReorderTechnique`).
  ///
  /// \see Cal::DynamicReordering, Cal::ReorderTechnique
  //////////////////////////////////////////////////////////////////////////////
  enum ReorderMethod {
    BF = CAL_REORDER_METHOD_BF,
    DF = CAL_REORDER_METHOD_DF
  };

  /// \copybrief Cal_BddDynamicReordering
  void DynamicReordering(ReorderTechnique technique, ReorderMethod method = ReorderMethod::DF)
  {
    Cal_BddDynamicReordering(this->_bddManager, technique, method);
  }

  /// \copybrief Cal_BddReorder
  void Reorder()
  { Cal_BddReorder(this->_bddManager); }

  //////////////////////////////////////////////////////////////////////////////
  // Association List

  // TODO: use RAII to hide association identifiers
  // TODO: container-based functions

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_AssociationInit
  ///
  /// \param pairs If `false`, the array assumed to be an array of variables.
  ///              If `true`, it is interpreted as consecutive pairs of
  ///              variables.
  ///
  /// \see Cal::AssociationSetCurrent
  //////////////////////////////////////////////////////////////////////////////
  template<typename IT>
  int AssociationInit(IT begin, IT end, const bool pairs = false)
  {
    std::vector<Cal_Bdd> c_arg =
      BDD::C_Bdd_vector(this->_bddManager, std::move(begin), std::move(end));

    const int res = Cal_AssociationInit(this->_bddManager, c_arg.data(), pairs);

    BDD::Free(this->_bddManager, c_arg.begin(), c_arg.end());

    return res;
  }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_AssociationSetCurrent
  ///
  /// \see Cal::AssociationQuit
  //////////////////////////////////////////////////////////////////////////////
  int AssociationSetCurrent(int i)
  { return Cal_AssociationSetCurrent(this->_bddManager, i); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_AssociationQuit
  //////////////////////////////////////////////////////////////////////////////
  void AssociationQuit(int i)
  { Cal_AssociationQuit(this->_bddManager, i); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_TempAssociationInit
  ///
  /// \see Cal::AssociationInit
  //////////////////////////////////////////////////////////////////////////////
  template<typename IT>
  void TempAssociationInit(IT begin, const IT end, const bool pairs = false)
  {
    std::vector<Cal_Bdd> c_arg =
      BDD::C_Bdd_vector(this->_bddManager, std::move(begin), std::move(end));

    Cal_TempAssociationInit(this->_bddManager, c_arg.data(), pairs);

    BDD::Free(this->_bddManager, c_arg.begin(), c_arg.end());
  }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_TempAssociationAugment
  //////////////////////////////////////////////////////////////////////////////
  template<typename IT>
  void TempAssociationAugment(IT begin, const IT end, const bool pairs = false)
  {
    std::vector<Cal_Bdd> c_arg =
      BDD::C_Bdd_vector(this->_bddManager, std::move(begin), std::move(end));

    Cal_TempAssociationAugment(this->_bddManager, c_arg.data(), pairs);

    BDD::Free(this->_bddManager, c_arg.begin(), c_arg.end());
  }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_TempAssociationQuit
  //////////////////////////////////////////////////////////////////////////////
  void TempAssociationQuit()
  { Cal_TempAssociationQuit(this->_bddManager); }

  //////////////////////////////////////////////////////////////////////////////
  // Save / Load BDDs

  // BDD UndumpBdd(IT vars_begin, IT vars_end, FILE *f, int &error)
  // BDD DumpBdd(const BDD &f, IT vars_begin, IT vars_end, FILE *f, int &error)

  //////////////////////////////////////////////////////////////////////////////
  // BDD Constructors

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddNull
  //////////////////////////////////////////////////////////////////////////////
  BDD Null() const
  { return BDD(this->_bddManager, Cal_BddNull(this->_bddManager)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddOne
  //////////////////////////////////////////////////////////////////////////////
  BDD One() const
  { return BDD(this->_bddManager, Cal_BddOne(this->_bddManager)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddZero
  //////////////////////////////////////////////////////////////////////////////
  BDD Zero() const
  { return BDD(this->_bddManager, Cal_BddZero(this->_bddManager)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddManagerGetVarWithId
  //////////////////////////////////////////////////////////////////////////////
  BDD Id(Id_t id) const
  { return BDD(this->_bddManager, Cal_BddManagerGetVarWithId(this->_bddManager, id)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddManagerGetVarWithIndex
  //////////////////////////////////////////////////////////////////////////////
  BDD Index(Index_t idx) const
  { return BDD(this->_bddManager, Cal_BddManagerGetVarWithIndex(this->_bddManager, idx)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddManagerCreateNewVarFirst
  //////////////////////////////////////////////////////////////////////////////
  BDD CreateNewVarFirst()
  { return BDD(this->_bddManager, Cal_BddManagerCreateNewVarFirst(this->_bddManager)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddManagerCreateNewVarLast
  //////////////////////////////////////////////////////////////////////////////
  BDD CreateNewVarLast()
  { return BDD(this->_bddManager, Cal_BddManagerCreateNewVarLast(this->_bddManager)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddManagerCreateNewVarBefore
  //////////////////////////////////////////////////////////////////////////////
  BDD CreateNewVarBefore(const BDD &x)
  { return BDD(this->_bddManager, Cal_BddManagerCreateNewVarBefore(this->_bddManager, x._bdd)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddManagerCreateNewVarAfter
  //////////////////////////////////////////////////////////////////////////////
  BDD CreateNewVarAfter(const BDD &x)
  { return BDD(this->_bddManager, Cal_BddManagerCreateNewVarAfter(this->_bddManager, x._bdd)); }

  //////////////////////////////////////////////////////////////////////////////
  // BDD Predicates

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::IsNull
  //////////////////////////////////////////////////////////////////////////////
  bool IsNull(const BDD &f) const
  { return f.IsNull(); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::IsOne
  //////////////////////////////////////////////////////////////////////////////
  bool IsOne(const BDD &f) const
  { return f.IsOne(); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::IsZero
  //////////////////////////////////////////////////////////////////////////////
  bool IsZero(const BDD &f) const
  { return f.IsZero(); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::IsConst
  //////////////////////////////////////////////////////////////////////////////
  bool IsConst(const BDD &f) const
  { return f.IsConst(); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::IsCube
  //////////////////////////////////////////////////////////////////////////////
  bool IsCube(const BDD &f) const
  { return f.IsCube(); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::IsEqualTo
  //////////////////////////////////////////////////////////////////////////////
  bool IsEqual(const BDD &f, const BDD &g) const
  { return f.IsEqualTo(g); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::DependsOn
  //////////////////////////////////////////////////////////////////////////////
  bool DependsOn(const BDD &f, const BDD &var) const
  { return f.DependsOn(var); }

  //////////////////////////////////////////////////////////////////////////////
  // BDD Information

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::SatisfyingFraction()
  //////////////////////////////////////////////////////////////////////////////
  double SatisfyingFraction(const BDD &f)
  { return f.SatisfyingFraction(); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::Size
  //////////////////////////////////////////////////////////////////////////////
  unsigned long Size(const BDD &f, bool negout = true)
  { return f.Size(negout); }

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Similar to `Cal::Size` for an iterator of BDDs. But, this accounts
  /// for sharing of nodes.
  ///
  /// \param negout If `false` then counting pretends the BDD does not have
  ///               negative-output pointers (complement edges).
  //////////////////////////////////////////////////////////////////////////////
  template<typename IT>
  unsigned long Size(IT begin, IT end, bool negout = true)
  {
    static_assert(std::is_same_v<typename IT::value_type, BDD>,
                  "Must be called with iterator for BDD");

    std::vector<Cal_Bdd> c_arg =
      BDD::C_Bdd_vector(this->_bddManager, std::move(begin), std::move(end));

    const unsigned long res = Cal_BddSizeMultiple(this->_bddManager, c_arg.data(), negout);

    BDD::Free(this->_bddManager, c_arg.begin(), c_arg.end());

    return res;
  }

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Similar to `Cal::Size` for a container of BDDs. But, this accounts
  /// for sharing of nodes.
  ///
  /// \param negout If `false` then counting pretends the BDD does not have
  ///               negative-output pointers (complement edges).
  //////////////////////////////////////////////////////////////////////////////
  template<typename Container>
  unsigned long Size(Container c, bool negout = true)
  { return Size(std::begin(c), std::end(c), negout); }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////
  // container_t<BDD> Support(const BDD &f);

  //////////////////////////////////////////////////////////////////////////////
  // Manipulation

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::Identity
  //////////////////////////////////////////////////////////////////////////////
  BDD Identity(const BDD &f)
  { return f.Identity(); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::Regular
  //////////////////////////////////////////////////////////////////////////////
  BDD Regular(const BDD &f)
  { return f.Regular(); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::Not
  //////////////////////////////////////////////////////////////////////////////
  BDD Not(const BDD &f)
  { return f.Not(); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::Compose
  //////////////////////////////////////////////////////////////////////////////
  BDD Compose(const BDD &f, const BDD &g, const BDD &h)
  { return f.Compose(g, h); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::Intersects
  //////////////////////////////////////////////////////////////////////////////
  BDD Intersects(const BDD &f, const BDD &g)
  { return f.Intersects(g); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::Implies
  //////////////////////////////////////////////////////////////////////////////
  BDD Implies(const BDD &f, const BDD &g)
  { return f.Implies(g); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::ITE
  //////////////////////////////////////////////////////////////////////////////
  BDD ITE(const BDD &f, const BDD &g, const BDD &h)
  { return f.ITE(g, h); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::And
  //////////////////////////////////////////////////////////////////////////////
  BDD And(const BDD &f, const BDD &g)
  { return f.And(g); }

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Logical AND of iterator of `BDD` or `int`.
  ///
  /// \details If `IT::value_type` is `int` then the integers are converted into
  /// a `BDD` with `Call::Id`.
  //////////////////////////////////////////////////////////////////////////////
  template<typename IT>
  BDD And(IT begin, IT end)
  {
    std::vector<Cal_Bdd> c_arg =
      BDD::C_Bdd_vector(this->_bddManager, std::move(begin), std::move(end));

    const BDD res = Cal_BddMultiwayAnd(this->_bddManager, c_arg.data());

    BDD::Free(this->_bddManager, c_arg.begin(), c_arg.end());

    return res;
  }

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Logical AND of container with `BDD`s or `int`s.
  ///
  /// \details If the container is of `int`s, the integers are converted into
  /// a `BDD` with `Call::Id`.
  //////////////////////////////////////////////////////////////////////////////
  template<typename Container>
  BDD And(const Container &c)
  { return And(std::begin(c), std::end(c)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::Nand
  //////////////////////////////////////////////////////////////////////////////
  BDD Nand(const BDD &f, const BDD &g)
  { return f.Nand(g); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::Or
  //////////////////////////////////////////////////////////////////////////////
  BDD Or(const BDD &f, const BDD &g)
  { return f.Or(g); }

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Logical OR of iterator of `BDD` or `int`.
  ///
  /// \details If `IT::value_type` is `int` then the integers are converted into
  /// a `BDD` with `Call::Id`.
  //////////////////////////////////////////////////////////////////////////////
  template<typename IT>
  BDD Or(IT begin, IT end)
  {
    std::vector<Cal_Bdd> c_arg =
      BDD::C_Bdd_vector(this->_bddManager, std::move(begin), std::move(end));

    const BDD res = Cal_BddMultiwayOr(this->_bddManager, c_arg.data());

    BDD::Free(this->_bddManager, c_arg.begin(), c_arg.end());

    return res;
  }

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Logical OR of container with `BDD`s or `int`s.
  ///
  /// \details If the container is of `int`s, the integers are converted into
  /// a `BDD` with `Call::Id`.
  //////////////////////////////////////////////////////////////////////////////
  template<typename Container>
  BDD Or(const Container &c)
  { return Or(std::begin(c), std::end(c)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD:Nor
  //////////////////////////////////////////////////////////////////////////////
  BDD Nor(const BDD &f, const BDD &g)
  { return f.Nor(g); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD:Xor
  //////////////////////////////////////////////////////////////////////////////
  BDD Xor(const BDD &f, const BDD &g)
  { return f.Xor(g); }

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Logical XOR of iterator of `BDD` or `int`.
  ///
  /// \details If the container is of `int`s, the integers are converted into
  /// a `BDD` with `Call::Id`.
  //////////////////////////////////////////////////////////////////////////////
  template<typename IT>
  BDD Xor(IT begin, IT end)
  {
    std::vector<Cal_Bdd> c_arg =
      BDD::C_Bdd_vector(this->_bddManager, std::move(begin), std::move(end));

    const BDD res = Cal_BddMultiwayXor(this->_bddManager, c_arg.data());

    BDD::Free(this->_bddManager, c_arg.begin(), c_arg.end());

    return res;
  }

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Logical XOR of container with `BDD`s or `int`s.
  ///
  /// \details If the container is of `int`s, the integers are converted into
  /// a `BDD` with `Call::Id`.
  //////////////////////////////////////////////////////////////////////////////
  template<typename Container>
  BDD Xor(const Container &c)
  { return Xor(std::begin(c), std::end(c)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD:Xnor
  //////////////////////////////////////////////////////////////////////////////
  BDD Xnor(const BDD &f, const BDD &g)
  { return f.Xnor(g); }

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Pairwise AND of `BDD`s or `int`s provided by an iterator.
  ///
  /// \details If `IT::value_type` is `int` then the integers are converted into
  /// a `BDD` with `Call::Id`.
  //////////////////////////////////////////////////////////////////////////////
  template<typename IT>
  std::vector<BDD>
  PairwiseAnd(IT begin, IT end)
  {
    std::vector<Cal_Bdd> c_arg =
      BDD::C_Bdd_vector(this->_bddManager, std::move(begin), std::move(end));

    std::vector<BDD> res =
      BDD::From_C_Array(this->_bddManager, Cal_BddPairwiseAnd(this->_bddManager, c_arg.data()));

    BDD::Free(this->_bddManager, c_arg.begin(), c_arg.end());

    return res;
  }

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Pairwise AND of `BDD`s or `int`s within a container.
  ///
  /// \details If the container is of `int`s, the integers are converted into
  /// a `BDD` with `Call::Id`.
  //////////////////////////////////////////////////////////////////////////////
  template<typename Container>
  std::vector<BDD>
  PairwiseAnd(const Container &c)
  { return PairwiseAnd(std::begin(c), std::end(c)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Pairwise OR of `BDD`s or `int`s provided by an iterator.
  ///
  /// \details If `IT::value_type` is `int` then the integers are converted into
  /// a `BDD` with `Call::Id`.
  //////////////////////////////////////////////////////////////////////////////
  template<typename IT>
  std::vector<BDD>
  PairwiseOr(IT begin, IT end)
  {
    std::vector<Cal_Bdd> c_arg =
      BDD::C_Bdd_vector(this->_bddManager, std::move(begin), std::move(end));

    std::vector<BDD> res =
      BDD::From_C_Array(this->_bddManager, Cal_BddPairwiseOr(this->_bddManager, c_arg.data()));

    BDD::Free(this->_bddManager, c_arg.begin(), c_arg.end());

    return res;
  }

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Pairwise OR of `BDD`s or `int`s within a container.
  ///
  /// \details If the container is of `int`s, the integers are converted into
  /// a `BDD` with `Call::Id`.
  //////////////////////////////////////////////////////////////////////////////
  template<typename Container>
  std::vector<BDD>
  PairwiseOr(const Container &c)
  { return PairwiseOr(std::begin(c), std::end(c)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Pairwise XOR of `BDD`s or `int`s provided by an iterator.
  ///
  /// \details If `IT::value_type` is `int` then the integers are converted into
  /// a `BDD` with `Call::Id`.
  //////////////////////////////////////////////////////////////////////////////
  template<typename IT>
  std::vector<BDD>
  PairwiseXor(IT begin, IT end)
  {
    std::vector<Cal_Bdd> c_arg =
      BDD::C_Bdd_vector(this->_bddManager, std::move(begin), std::move(end));

    std::vector<BDD> res =
      BDD::From_C_Array(this->_bddManager, Cal_BddPairwiseXor(this->_bddManager, c_arg.data()));

    BDD::Free(this->_bddManager, c_arg.begin(), c_arg.end());

    return res;
  }

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Pairwise XOR of `BDD`s or `int`s within a container.
  ///
  /// \details If the container is of `int`s, the integers are converted into
  /// a `BDD` with `Call::Id`.
  //////////////////////////////////////////////////////////////////////////////
  template<typename Container>
  std::vector<BDD>
  PairwiseXor(const Container &c)
  { return PairwiseXor(std::begin(c), std::end(c)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::Satisfy
  //////////////////////////////////////////////////////////////////////////////
  BDD Satisfy(const BDD &f)
  { return f.Satisfy(); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::SatisfySupport
  //////////////////////////////////////////////////////////////////////////////
  BDD SatisfySupport(const BDD &f)
  { return f.SatisfySupport(); }

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////
  // BDD Substitute(const BDD &f)

  //////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////////////
  // BDD VarSubstitute(const BDD &f)

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::SwapVars
  //////////////////////////////////////////////////////////////////////////////
  BDD SwapVars(const BDD &f, const BDD &g, const BDD &h)
  { return f.SwapVars(g, h); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddExists
  ///
  /// \copydetails Cal_BddExists
  ///
  /// \see Cal::AssociationInit, Cal::TempAssociationInit
  //////////////////////////////////////////////////////////////////////////////
  BDD Exists(const BDD &f)
  { return BDD(this->_bddManager, Cal_BddExists(this->_bddManager, f._bdd)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddForAll
  ///
  /// \copydetails Cal_BddForAll
  ///
  /// \see Cal::AssociationInit, Cal::TempAssociationInit
  //////////////////////////////////////////////////////////////////////////////
  BDD ForAll(const BDD &f)
  { return BDD(this->_bddManager, Cal_BddForAll(this->_bddManager, f._bdd)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief Cal_BddRelProd
  ///
  /// \copydetails Cal_BddRelProd
  ///
  /// \see Cal::AssociationInit, Cal::TempAssociationInit
  //////////////////////////////////////////////////////////////////////////////
  BDD RelProd(const BDD &f, const BDD &g)
  { return BDD(this->_bddManager, Cal_BddRelProd(this->_bddManager, f._bdd, g._bdd)); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::Cofactor
  //////////////////////////////////////////////////////////////////////////////
  BDD Cofactor(const BDD &f, const BDD &c)
  { return f.Cofactor(c); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::Reduce
  //////////////////////////////////////////////////////////////////////////////
  BDD Reduce(const BDD &f, const BDD &c)
  { return f.Reduce(c); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::Between
  //////////////////////////////////////////////////////////////////////////////
  BDD Between(const BDD &fMin, const BDD &fMax)
  { return BDD(this->_bddManager, Cal_BddBetween(this->_bddManager, fMin._bdd, fMax._bdd)); }

  //////////////////////////////////////////////////////////////////////////////
  // BDD Node Access / Traversal

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::If
  //////////////////////////////////////////////////////////////////////////////
  BDD If(const BDD &f) const
  { return f.If(); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::Id
  //////////////////////////////////////////////////////////////////////////////
  Id_t IfId(const BDD &f) const
  { return f.Id(); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::Index
  //////////////////////////////////////////////////////////////////////////////
  Index_t IfIndex(const BDD &f) const
  { return f.Index(); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::Then
  //////////////////////////////////////////////////////////////////////////////
  BDD Then(const BDD &f)
  { return f.Then(); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::Else
  //////////////////////////////////////////////////////////////////////////////
  BDD Else(const BDD &f)
  { return f.Else(); }

  //////////////////////////////////////////////////////////////////////////////
  // Debugging

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::Print
  //////////////////////////////////////////////////////////////////////////////
  void Print(const BDD &f, FILE *fp = stdout) const
  { f.Print(fp); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::FunctionPrint
  //////////////////////////////////////////////////////////////////////////////
  void FunctionPrint(const BDD &f, std::string &name) const
  { f.FunctionPrint(name); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copydoc BDD::Profile
  //////////////////////////////////////////////////////////////////////////////
  std::vector<long> Profile(const BDD &f, bool negout = true) const
  { return f.Profile(negout); }

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Similar to `Cal::Profile` for an iterator of BDDs. But, this
  /// accounts for sharing of nodes.
  ///
  /// \param negout If `false` then counting pretends the BDD does not have
  ///               negative-output pointers (complement edges).
  //////////////////////////////////////////////////////////////////////////////
  template<typename IT>
  std::vector<long> Profile(IT begin, IT end, bool negout = true) const
  {
    std::vector<Cal_Bdd> c_arg =
      BDD::C_Bdd_vector(this->_bddManager, std::move(begin), std::move(end));

    std::vector<long> levelCounts;
    levelCounts.reserve(this->Vars()+1);

    Cal_BddProfileMultiple(this->_bddManager,
                           c_arg.data(),
                           levelCounts.data(),
                           negout);

    BDD::Free(this->_bddManager, c_arg.begin(), c_arg.end());

    return levelCounts;
  }

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Similar to `Cal::Profile` for a container of BDDs. But, this
  /// accounts for sharing of nodes.
  ///
  /// \param negout If `false` then counting pretends the BDD does not have
  ///               negative-output pointers (complement edges).
  //////////////////////////////////////////////////////////////////////////////
  template<typename Container>
  std::vector<long> Profile(const Container &c, bool negout = true) const
  { return Profile(c.begin(), c.end(), negout); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief BDD::PrintProfile
  //////////////////////////////////////////////////////////////////////////////
  void PrintProfile(const BDD &f, int lineLength = 79, FILE *fp = stdout) const
  { return f.PrintProfile(lineLength, fp); }

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Similar to `Cal::PrintProfile` for an iterator of BDDs. But, this
  /// accounts for sharing of nodes.
  ///
  /// \param negout If `false` then counting pretends the BDD does not have
  ///               negative-output pointers (complement edges).
  //////////////////////////////////////////////////////////////////////////////
  template<typename IT>
  void PrintProfile(IT begin, IT end,
                    int lineLength = 79,
                    FILE *fp = stdout) const
  {
    std::vector<Cal_Bdd> c_arg =
      BDD::C_Bdd_vector(this->_bddManager, std::move(begin), std::move(end));

    // TODO: Extend to use your own NamingFn (and its environment).
    Cal_BddPrintProfileMultiple(this->_bddManager, c_arg.data(),
                                Cal_BddNamingFnNone, NULL,
                                lineLength, fp);

    BDD::Free(this->_bddManager, c_arg.begin(), c_arg.end());
  }

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Similar to `Cal::PrintProfile` for a container of BDDs. But, this
  /// accounts for sharing of nodes.
  ///
  /// \param negout If `false` then counting pretends the BDD does not have
  ///               negative-output pointers (complement edges).
  //////////////////////////////////////////////////////////////////////////////
  template<typename Container>
  void PrintProfile(const Container &c,
                    int lineLength = 79,
                    FILE *fp = stdout) const
  { PrintProfile(c.begin, c.end, lineLength, fp); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief BDD::FunctionProfile
  //////////////////////////////////////////////////////////////////////////////
  std::vector<long> FunctionProfile(const BDD &f) const
  { return f.FunctionProfile(); }

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Similar to `Cal::FunctionProfile` for an iterator of BDDs. But,
  /// this accounts for sharing of nodes.
  ///
  /// \param negout If `false` then counting pretends the BDD does not have
  ///               negative-output pointers (complement edges).
  //////////////////////////////////////////////////////////////////////////////
  template<typename IT>
  std::vector<long> FunctionProfile(IT begin, IT end) const
  {
    std::vector<Cal_Bdd> c_arg =
      BDD::C_Bdd_vector(this->_bddManager, std::move(begin), std::move(end));

    std::vector<long> funcCounts;
    funcCounts.reserve(Vars()+1);

    Cal_BddFunctionProfileMultiple(this->_bddManager, c_arg.data(), funcCounts.data());

    BDD::Free(this->_bddManager, c_arg.begin(), c_arg.end());

    return funcCounts;
  }

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Similar to `Cal::FunctionProfile` for a container of BDDs. But,
  /// this accounts for sharing of nodes.
  ///
  /// \param negout If `false` then counting pretends the BDD does not have
  ///               negative-output pointers (complement edges).
  //////////////////////////////////////////////////////////////////////////////
  template<typename Container>
  std::vector<long> FunctionProfile(const Container &c) const
  { return FunctionProfile(c.begin(), c.end()); }

  //////////////////////////////////////////////////////////////////////////////
  /// \copybrief BDD::PrintFunctionProfile
  //////////////////////////////////////////////////////////////////////////////
  void PrintFunctionProfile(const BDD &f,
                            int lineLength = 79,
                            FILE *fp = stdout) const
  { return f.PrintFunctionProfile(lineLength, fp); }


  //////////////////////////////////////////////////////////////////////////////
  /// \brief Similar to `Cal::PrintFunctionProfile` for an iterator of BDDs.
  /// But, this accounts for sharing of nodes.
  ///
  /// \param negout If `false` then counting pretends the BDD does not have
  ///               negative-output pointers (complement edges).
  //////////////////////////////////////////////////////////////////////////////
  template<typename IT>
  void PrintFunctionProfile(IT begin, IT end,
                    int lineLength = 79,
                    FILE *fp = stdout) const
  {
    std::vector<Cal_Bdd> c_arg =
      BDD::C_Bdd_vector(this->_bddManager, std::move(begin), std::move(end));

    // TODO: Extend to use your own NamingFn (and its environment).
    Cal_BddPrintFunctionProfileMultiple(this->_bddManager, c_arg.data(),
                                        Cal_BddNamingFnNone, NULL,
                                        lineLength, fp);

    BDD::Free(this->_bddManager, c_arg.begin(), c_arg.end());
  }

  //////////////////////////////////////////////////////////////////////////////
  /// \brief Similar to `Cal::PrintFunctionProfile` for a container of BDDs.
  /// But, this accounts for sharing of nodes.
  ///
  /// \param negout If `false` then counting pretends the BDD does not have
  ///               negative-output pointers (complement edges).
  //////////////////////////////////////////////////////////////////////////////
  template<typename Container>
  void PrintFunctionProfile(const Container &c,
                            int lineLength = 79,
                            FILE *fp = stdout) const
  { PrintFunctionProfile(c.begin, c.end, lineLength, fp); }

  //////////////////////////////////////////////////////////////////////////////
  // BDD Pipelining

  // TODO: class Pipeline using RAII and operator overloading

  //////////////////////////////////////////////////////////////////////////////
  // NOTE: These should never be exposed (hidden inside of the BDD class)

  // void Free();
  // void UnFree();
};

/// \}
////////////////////////////////////////////////////////////////////////////////

#endif /* _CALOBJ */
